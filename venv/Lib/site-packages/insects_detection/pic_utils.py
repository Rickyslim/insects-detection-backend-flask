import numpy as np
import cv2 as cv
import os
import matplotlib.pyplot as plt
class pic_tools():
    @staticmethod
    def rename_imgs(gallery_path,green_house_tag,img_type):
        for root, dirs, files in os.walk(gallery_path):
            for name, index in zip(files, range(len(files))):
                row = int((index) / 8) + 1
                column = (math.floor(index / 2)) % 4 + 1
                side_mediate = (index) % 4 + 1
                side = "A" if side_mediate % 2 != 0 else "B"
                # print(row,column,side)
                filepath = (os.path.join(root, name))
                filename = name.split(".")[0]
                new_filename = green_house_tag + str(row) + "-" + str(column) + "-" + side
                print(new_filename)
                os.renames(filepath, os.path.join(root, new_filename + img_type))
    @staticmethod
    def read_imgs(img_url):
        # 使用imdecode函数进行读取
        img = cv.imdecode(np.fromfile(img_url, dtype=np.uint8), -1)
        return img

    @staticmethod
    def read_imgs_from_dir(dir):
        filepath=[]
        for root, dirs, files in os.walk(dir):
            for name in files:
                filepath.append(os.path.join(root, name))
        return filepath

    #将处理后的图片进行存储
    @staticmethod
    def write_single_imgs(store_path,original_img_name,processed_img):
        # img_name=str(processed_img).rsplit('\\',1)[1]
        cv.imwrite(store_path+"\\"+original_img_name, processed_img)
        print(original_img_name+" 写入成功")

    @staticmethod
    def write_all_processed_imgs(from_dir,to_dir):
        origin_imgs_path=pic_tools.read_imgs_from_dir(from_dir)
        for ori_img_path in origin_imgs_path:
            _, filename = os.path.split(ori_img_path)
            ori_img = pic_tools.read_imgs(ori_img_path)
            processed_img=pic_tools.cutout_imgs(ori_img)
            pic_tools.write_single_imgs(to_dir,filename,processed_img)

    @staticmethod
    def cutout_imgs(img):
        #截取出粘虫板亮黄色部分
        lower = np.array([20, 70, 70], dtype="uint8")
        upper = np.array([100, 255, 255], dtype="uint8")
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        mask = cv.inRange(hsv, lower, upper)
        image = cv.bitwise_and(img, img, mask=mask)
        # cv.namedWindow('1',2)
        # cv.imshow('1',image)
        gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)  # 转换为灰度图
        contours, hierarchy = cv.findContours(gray, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)  # 轮廓检测
        height, width = img.shape[:2]
        index = 0
        max = 0
        for c in range(len(contours)):
            x, y, w, h = cv.boundingRect(contours[c])
            if h > height or w > width:
                continue
            area = cv.contourArea(contours[c])
            if area > max:
                max = area
                index = c
        x, y, w, h = cv.boundingRect(contours[index])
        # print(len(contours))
        # print(index)
        result = np.zeros(img.shape, dtype=np.uint8)
        cv.drawContours(result, contours, index, (0, 0, 255), 2)  # 绘制轮廓
        # cv.namedWindow("5", 2)#创建一个窗口
        # cv.imshow("5", result)  #显示灰度图
        result1 = np.zeros(img.shape, dtype=np.uint8)
        cv.rectangle(result1, (x, y, w, h), (0, 225, 0), 20)  # 绘制矩形
        # cv.namedWindow("6", 2)#创建一个窗口
        # cv.imshow("6", result1)  #显示灰度图
        cropped = image[y:y + h - 50, x:x + w - 50]
        # cv.namedWindow("7", 2)#创建一个窗口
        # cv.imshow("7", cropped)  #显示灰度图
        # print(cropped.shape)3100,2400
        dst = cv.resize(cropped, (1000, 900), interpolation=cv.INTER_CUBIC)
        # print(dst.shape)
        # cv.namedWindow("8", 2)#创建一个窗口
        # cv.imshow("8", dst)  #显示灰度图
        # cv.waitKey(0)
        return dst

    @staticmethod
    def prewitt_operator(img):
        grayImage = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        # print(type(grayImage[0,0]))
        kernelx = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]], dtype=int)  # prewitt 1算子
        # print(type(kernelx[0,0]))
        kernely = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]], dtype=int)  # prewitt 2算子
        x = cv.filter2D(grayImage, cv.CV_16S, kernelx)
        y = cv.filter2D(grayImage, cv.CV_16S, kernely)
        # print(type(x[0,0]))
        absx = cv.convertScaleAbs(x)
        absy = cv.convertScaleAbs(y)
        # print(type(absx[0,0]))
        Prewitt = cv.addWeighted(absx, 0.5, absy, 0.5, 0)
        return Prewitt

    @staticmethod
    def getContours(Prewitt):
        ret, Prewitt = cv.threshold(Prewitt, 35, 255, cv.THRESH_BINARY)  # 输入灰度图，输出二值图
        element = cv.getStructuringElement(cv.MORPH_CROSS, (1, 1))  # 形态学去噪
        Prewitt = cv.morphologyEx(Prewitt, cv.MORPH_OPEN, element)  # 开运算去噪
        contours, hierarchy = cv.findContours(Prewitt, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        cv.drawContours(Prewitt, contours, -1, (120, 0, 0), 2)  # 绘制轮廓
        return contours

    #粘虫板虫害特征提取，包括9个颜色特征
    @staticmethod
    def extract_hue_characteristics(img):
        Prewitt = pic_tools.prewitt_operator(img)
        contours = pic_tools.getContours(Prewitt)
        count = 0
        margin = 5
        X_train = np.empty(shape=[0, 9])
        # 遍历找到的所有昆虫
        for cont in contours:
            ares = cv.contourArea(cont)  # 计算包围性状的面积
            if ares < 10 or ares > 120:  # 过滤面积小于10的形状
                continue
            count += 1  # 总体计数加1
            rect = cv.minAreaRect(cont)
            box = np.int0(cv.boxPoints(rect))
            rect_w, rect_h = int(rect[1][0]) + 1, int(rect[1][1]) + 1
            h, w = img.shape[:2]
            if rect_w <= rect_h:
                x, y = box[1][0], box[1][1]
                M2 = cv.getRotationMatrix2D((x, y), rect[2], 1)
                rotated_image = cv.warpAffine(img, M2, (w, h))
                rotated_canvas = rotated_image[y:y + rect_h + margin + 1, x:x + rect_w + margin + 1]
            else:
                x, y = box[2][0], box[2][1]  # 旋转中心
                M2 = cv.getRotationMatrix2D((x, y), rect[2] + 90, 1)
                rotated_image = cv.warpAffine(img, M2, (w, h))
                rotated_canvas = rotated_image[y:y + rect_w + margin + 1, x:x + rect_h + margin + 1]

            if rotated_canvas.shape[0] == 0 or rotated_canvas.shape[1] == 0:
                continue
            b, g, r = cv.split(rotated_canvas)
            b_mean = np.mean(b)
            g_mean = np.mean(g)
            r_mean = np.mean(r)
            rotated_canvas_HSV = cv.cvtColor(rotated_canvas, cv.COLOR_BGR2HSV)
            h, s, v = cv.split(rotated_canvas_HSV)
            h_mean = np.mean(h)
            s_mean = np.mean(s)
            v_mean = np.mean(v)
            rotated_canvas_LAB = cv.cvtColor(rotated_canvas, cv.COLOR_BGR2LAB)
            l, a, b = cv.split(rotated_canvas_LAB)
            l_mean = np.mean(l)
            a_mean = np.mean(a)
            b_mean = np.mean(b)
            X_train = np.append(X_train, [[b_mean, g_mean, r_mean, h_mean, s_mean, v_mean, l_mean, a_mean, b_mean]],axis=0)
        return X_train

    @staticmethod
    def extract_all_imgs_characteristcs(img_dir,storage_dir):
        imgs_path = pic_tools.read_imgs_from_dir(img_dir)
        for img_path in imgs_path:
            _, filename = os.path.split(img_path)
            fn_no_appendix=filename.split('.')[0]
            with open(storage_dir + '\\' + fn_no_appendix+'.txt', 'w'):
                pass
            img = pic_tools.read_imgs(img_path)
            img_chas = pic_tools.extract_hue_characteristics(img)
            np.savetxt(storage_dir + '\\' + fn_no_appendix+'.txt',img_chas,fmt=["%.8f"]*img_chas.shape[1],delimiter=" ",newline="\n")
            print(fn_no_appendix+" 数据特征写入完毕")
